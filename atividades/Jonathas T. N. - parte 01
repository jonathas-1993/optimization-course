### Universidade Federal do Amazonas  
### Programa de Pós-Graduação em Engenharia Elétrica  - PPGEE
### Otimização - Doutorado  

**Aluno:** Jonathas Tavares Neves  

---

## Exercício 2.2 (Forma analítica)

Para cada uma das seguintes funções, realize as seguintes operações:  

1. Calcule o gradiente.  
2. Calcule o hessiano.  
3. Especifique (e justifique) se a função é convexa, côncava ou nenhuma das opções.  
4. Calcule a curvatura da função em uma direção \(d\) no ponto especificado \(\bar{x}\).

---

### Funções  

1. $ f(x_1, x_2) = \frac{1}{2}x_1^2 + \frac{9}{2}x_2^2, \quad \text{com } \bar{x} = (0, 0)^T.
$


2. $ f(x_1, x_2) = \frac{1}{3}x_1^3 + x_2^3 - x_1 - x_2, \quad \text{com } \bar{x} = (9, 1)^T.
$


3. $ f(x_1, x_2) = (x_1 - 2)^4 + (x_1 - 2)^2x_2^2 + (x_2 + 1)^2, \quad \text{com } \bar{x} = (2, -1)^T.
$


4. $ f(x_1, x_2) = x_1^2 + 2x_1x_2 + 2x_2^2, \quad \text{com } \bar{x} = (1, 1)^T.
$


5. $ f(x_1, x_2) = x_1^2 - x_1x_2 + 2x_2^2 - 2x_1 + e^{x_1 + x_2}, \quad \text{com } \bar{x} = (0, 0)^T.
$

---


import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Função 1
def ex221(x):
    # Função
    f = 0.5 * x[0]**2 + (9/2) * x[1]**2
    
    # Gradiente
    g = np.array([x[0], 9 * x[1]])
    
    # Matriz Hessiana
    h = np.array([[1.0, 0.0],
                  [0.0, 9.0]])
    
    return f, g, h

# Curvatura
def curvature(x, d):
    _, _, h = ex221(x)
    return np.dot(d.T, np.dot(h, d))

# Parâmetros iniciais
x0 = np.array([0.0, 0.0])
_, g, h = ex221(x0)

# Direções
d1 = -g  # Direção oposta ao gradiente
d2 = np.array([-0.1, -0.1])  # Direção arbitrária
d3 = np.array([0.1, 0.1])    # Direção arbitrária

# Cálculo da curvatura
print("Curvatura na direção d1:", curvature(x0, d1))
print("Curvatura na direção d2:", curvature(x0, d2))
print("Curvatura na direção d3:", curvature(x0, d3))

# Gráficos
x_vals = np.linspace(-2, 2, 400)
y_vals = np.linspace(-2, 2, 400)
X, Y = np.meshgrid(x_vals, y_vals)
Z = 0.5 * X**2 + (9/2) * Y**2

# Gráfico 3D interativo com Plotly
fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y, colorscale='Viridis')])
fig.update_layout(
    title="Gráfico 3D da Função 1",
    scene=dict(
        xaxis_title="x1",
        yaxis_title="x2",
        zaxis_title="f(x1, x2)"
    ),
    width=800,
    height=600
)
fig.show()

# Gráfico de contorno
plt.figure(figsize=(8, 6))
contours = plt.contour(X, Y, Z, levels=20, cmap='viridis')
plt.clabel(contours, inline=True, fontsize=8)

plt.plot(x0[0], x0[1], 'ro', label='x0 = [0,0]')
plt.arrow(x0[0], x0[1], d1[0], d1[1], color='b', head_width=0.05, label='d1')
plt.arrow(x0[0], x0[1], d2[0], d2[1], color='g', head_width=0.05, label='d2')
plt.arrow(x0[0], x0[1], d3[0], d3[1], color='m', head_width=0.05, label='d3')

plt.title('Curvas de nível e direções a partir de x0')
plt.xlabel('x1')
plt.ylabel('x2')
plt.legend()
plt.grid(True)
plt.axis('equal')
plt.show()

---------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Função 2

def ex222(x):
    # Função
    f = (1/3) * x[0]**3 + x[1]**3 - x[0] - x[1]
    
    # Gradiente
    g = np.array([x[0]**2 - 1, 3 * x[1]**2 - 1])
    
    # Matriz Hessiana
    h = np.array([[2 * x[0], 0.0],
                  [0.0, 6 * x[1]]])
    
    return f, g, h

# Curvatura
def curvature(x, d):
    _, _, h = ex222(x)
    return np.dot(d.T, np.dot(h, d))

# Parâmetros iniciais
x0 = np.array([9.0, 1.0])
_, g, h = ex222(x0)

# Direções
d1 = -g  # Direção oposta ao gradiente
d2 = np.array([9.1, 1.1])  # Direção arbitrária
d3 = np.array([8.9, 0.9])    # Direção arbitrária

# Cálculo da curvatura
print("Curvatura na direção d1:", curvature(x0, d1))
print("Curvatura na direção d2:", curvature(x0, d2))
print("Curvatura na direção d3:", curvature(x0, d3))

# Gráficos
x_vals = np.linspace(8, 10, 400)
y_vals = np.linspace(0, 2, 400)
X, Y = np.meshgrid(x_vals, y_vals)
Z = (1/3) * X**3 + Y**3 - X - Y

# Gráfico 3D interativo com Plotly
fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y, colorscale='Viridis')])
fig.update_layout(
    title="Gráfico 3D da Função 2",
    scene=dict(
        xaxis_title="x1",
        yaxis_title="x2",
        zaxis_title="f(x1, x2)"
    ),
    width=800,
    height=600
)
fig.show()

# Gráfico de contorno
plt.figure(figsize=(8, 6))
contours = plt.contour(X, Y, Z, levels=20, cmap='viridis')
plt.clabel(contours, inline=True, fontsize=8)

plt.plot(x0[0], x0[1], 'ro', label='x0 = [9,1]')
plt.arrow(x0[0], x0[1], d1[0], d1[1], color='b', head_width=0.05, label='d1')
plt.arrow(x0[0], x0[1], d2[0], d2[1], color='g', head_width=0.05, label='d2')
plt.arrow(x0[0], x0[1], d3[0], d3[1], color='m', head_width=0.05, label='d3')

plt.title('Curvas de nível e direções a partir de x0')
plt.xlabel('x1')
plt.ylabel('x2')
plt.legend()
plt.grid(True)
plt.axis('equal')
plt.show()

---------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Função 3
def ex223(x):
    # Função
    f = (x[0] - 2)**4 + (x[0] - 2)**2 * x[1]**2 + (x[1] + 1)**2
    
    # Gradiente
    g = np.array([
        4 * (x[0] - 2)**3 + 2 * (x[0] - 2) * x[1]**2,
        2 * (x[0] - 2)**2 * x[1] + 2 * (x[1] + 1)
    ])
    
    # Matriz Hessiana
    h = np.array([
        [12 * (x[0] - 2)**2 + 2 * x[1]**2, 4 * (x[0] - 2) * x[1]],
        [4 * (x[0] - 2) * x[1], 2 * (x[0] - 2)**2 + 2]
    ])
    
    return f, g, h

# Curvatura
def curvature(x, d):
    _, _, h = ex223(x)
    return np.dot(d.T, np.dot(h, d))

# Parâmetros iniciais
x0 = np.array([2.0, -1.0])
_, g, h = ex223(x0)

# Direções
d1 = -g  # Direção oposta ao gradiente
d2 = np.array([2.1, -1.1])  # Direção arbitrária
d3 = np.array([1.9, -0.9])    # Direção arbitrária

# Cálculo da curvatura
print("Curvatura na direção d1:", curvature(x0, d1))
print("Curvatura na direção d2:", curvature(x0, d2))
print("Curvatura na direção d3:", curvature(x0, d3))

# Gráficos
x_vals = np.linspace(1, 3, 400)
y_vals = np.linspace(-2, 0, 400)
X, Y = np.meshgrid(x_vals, y_vals)
Z = (X - 2)**4 + (X - 2)**2 * Y**2 + (Y + 1)**2

# Gráfico 3D interativo com Plotly
fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y, colorscale='Viridis')])
fig.update_layout(
    title="Gráfico 3D da Função 3",
    scene=dict(
        xaxis_title="x1",
        yaxis_title="x2",
        zaxis_title="f(x1, x2)"
    ),
    width=800,
    height=600
)
fig.show()

# Gráfico de contorno
plt.figure(figsize=(8, 6))
contours = plt.contour(X, Y, Z, levels=20, cmap='viridis')
plt.clabel(contours, inline=True, fontsize=8)

plt.plot(x0[0], x0[1], 'ro', label='x0 = [2,-1]')
plt.arrow(x0[0], x0[1], d1[0], d1[1], color='b', head_width=0.05, label='d1')
plt.arrow(x0[0], x0[1], d2[0], d2[1], color='g', head_width=0.05, label='d2')
plt.arrow(x0[0], x0[1], d3[0], d3[1], color='m', head_width=0.05, label='d3')

plt.title('Curvas de nível e direções a partir de x0')
plt.xlabel('x1')
plt.ylabel('x2')
plt.legend()
plt.grid(True)
plt.axis('equal')
plt.show()

---------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Função 4

def ex224(x):
    # Função
    f = x[0]**2 + 2 * x[0] * x[1] + 2 * x[1]**2
    
    # Gradiente
    g = np.array([2 * x[0] + 2 * x[1], 2 * x[0] + 4 * x[1]])
    
    # Matriz Hessiana
    h = np.array([[2.0, 2.0],
                  [2.0, 4.0]])
    
    return f, g, h

# Curvatura
def curvature(x, d):
    _, _, h = ex224(x)
    return np.dot(d.T, np.dot(h, d))

# Parâmetros iniciais
x0 = np.array([1.0, 1.0])
_, g, h = ex224(x0)

# Direções
d1 = -g  # Direção oposta ao gradiente
d2 = np.array([1.1, 1.1])  # Direção arbitrária
d3 = np.array([0.9, 0.9])    # Direção arbitrária

# Cálculo da curvatura
print("Curvatura na direção d1:", curvature(x0, d1))
print("Curvatura na direção d2:", curvature(x0, d2))
print("Curvatura na direção d3:", curvature(x0, d3))

# Gráficos
x_vals = np.linspace(0, 2, 400)
y_vals = np.linspace(0, 2, 400)
X, Y = np.meshgrid(x_vals, y_vals)
Z = X**2 + 2 * X * Y + 2 * Y**2

# Gráfico 3D interativo com Plotly
fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y, colorscale='Viridis')])
fig.update_layout(
    title="Gráfico 3D da Função 4",
    scene=dict(
        xaxis_title="x1",
        yaxis_title="x2",
        zaxis_title="f(x1, x2)"
    ),
    width=800,
    height=600
)
fig.show()

# Gráfico de contorno
plt.figure(figsize=(8, 6))
contours = plt.contour(X, Y, Z, levels=20, cmap='viridis')
plt.clabel(contours, inline=True, fontsize=8)

plt.plot(x0[0], x0[1], 'ro', label='x0 = [1,1]')
plt.arrow(x0[0], x0[1], d1[0], d1[1], color='b', head_width=0.05, label='d1')
plt.arrow(x0[0], x0[1], d2[0], d2[1], color='g', head_width=0.05, label='d2')
plt.arrow(x0[0], x0[1], d3[0], d3[1], color='m', head_width=0.05, label='d3')

plt.title('Curvas de nível e direções a partir de x0')
plt.xlabel('x1')
plt.ylabel('x2')
plt.legend()
plt.grid(True)
plt.axis('equal')
plt.show()

---------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Função 5

def ex225(x):
    # Função
    f = x[0]**2 - x[0] * x[1] + 2 * x[1]**2 - 2 * x[0] + np.exp(x[0] + x[1])
    
    # Gradiente
    g = np.array([
        2 * x[0] - x[1] - 2 + np.exp(x[0] + x[1]),
        -x[0] + 4 * x[1] + np.exp(x[0] + x[1])
    ])
    
    # Matriz Hessiana
    h = np.array([
        [2 + np.exp(x[0] + x[1]), -1 + np.exp(x[0] + x[1])],
        [-1 + np.exp(x[0] + x[1]), 4 + np.exp(x[0] + x[1])]
    ])
    
    return f, g, h

# Curvatura
def curvature(x, d):
    _, _, h = ex225(x)
    return np.dot(d.T, np.dot(h, d))

# Parâmetros iniciais
x0 = np.array([0.0, 0.0])
_, g, h = ex225(x0)

# Direções
d1 = -g  # Direção oposta ao gradiente
d2 = np.array([-1.0, -1.0])  # Direção arbitrária
d3 = np.array([1.0, 1.0])    # Direção arbitrária

# Cálculo da curvatura
print("Curvatura na direção d1:", curvature(x0, d1))
print("Curvatura na direção d2:", curvature(x0, d2))
print("Curvatura na direção d3:", curvature(x0, d3))

# Gráficos
x_vals = np.linspace(-1, 1, 400)
y_vals = np.linspace(-1, 1, 400)
X, Y = np.meshgrid(x_vals, y_vals)
Z = X**2 - X * Y + 2 * Y**2 - 2 * X + np.exp(X + Y)

# Gráfico 3D interativo com Plotly
fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y, colorscale='Viridis')])
fig.update_layout(
    title="Gráfico 3D da Função 5",
    scene=dict(
        xaxis_title="x1",
        yaxis_title="x2",
        zaxis_title="f(x1, x2)"
    ),
    width=800,
    height=600
)
fig.show()

# Gráfico de contorno
plt.figure(figsize=(8, 6))
contours = plt.contour(X, Y, Z, levels=20, cmap='viridis')
plt.clabel(contours, inline=True, fontsize=8)

plt.plot(x0[0], x0[1], 'ro', label='x0 = [0,0]')
plt.arrow(x0[0], x0[1], d1[0], d1[1], color='b', head_width=0.05, label='d1')
plt.arrow(x0[0], x0[1], d2[0], d2[1], color='g', head_width=0.05, label='d2')
plt.arrow(x0[0], x0[1], d3[0], d3[1], color='m', head_width=0.05, label='d3')

plt.title('Curvas de nível e direções a partir de x0')
plt.xlabel('x1')
plt.ylabel('x2')
plt.legend()
plt.grid(True)
plt.axis('equal')
plt.show()
